/**
 * build configuration for data-owner project
 * @author Yaxing Chen
 * @version 0.0.4
 */

/**
 * spark modules used in project
 * @see sbt-spark plugin
 */
sparkComponents ++= Seq("core", "sql", "catalyst")

/**
 * define a task to fetch flatbuffer library and build it to generate flatc executables
 * @return flatc executables
 */
val fetchFlatbuffersLibTask = TaskKey[File]("fetchFlatbuffersLib",
  "Fetches and builds the Flatbuffers library, returning its location.")
fetchFlatbuffersLibTask := {
  val flatbuffersSource = target.value / "flatbuffers" / (s"flatbuffers-" + flatbuffersVersion.value)
  if (!flatbuffersSource.exists) {
    // Fetch flatbuffers from local resource
    streams.value.log.info(s"Fetching Flatbuffers")
    val flatbuffersLoc = baseDirectory.value / "src" / "deps" / (s"flatbuffers-" + flatbuffersVersion.value + ".zip")
    if (!flatbuffersLoc.exists) {
      // Fetch flatbuffers from Github
      val flatbuffersUrl = new java.net.URL(
        s"https://github.com/google/flatbuffers/archive/v" + flatbuffersVersion.value + ".zip")
      IO.unzipURL(flatbuffersUrl, flatbuffersSource.getParentFile)
    }else{
      IO.unzip(flatbuffersLoc, flatbuffersSource.getParentFile)
    }
  }
  val flatc = flatbuffersSource / "flatc"
  if (!flatc.exists) {
    // Build flatbuffers with cmake
    import sys.process._
    streams.value.log.info(s"Building Flatbuffers")
    val nproc = java.lang.Runtime.getRuntime.availableProcessors
    if (Process(Seq(
      "cmake", "-G", "Unix Makefiles",
      "-DFLATBUFFERS_BUILD_TESTS=OFF",
      "-DFLATBUFFERS_BUILD_FLATLIB=OFF",
      "-DFLATBUFFERS_BUILD_FLATHASH=OFF",
      "-DFLATBUFFERS_BUILD_FLATC=ON",
      "-DCMAKE_CXX_FLAGS=-Wno-ignored-qualifiers"), flatbuffersSource).! != 0
      || Process(Seq("make", "-j" + nproc), flatbuffersSource).! != 0) {
      sys.error("Flatbuffers library build failed.")
    }
  }
  flatbuffersSource
}

/**
 * re-assign unmangedSourced by appending java files generated by flatbuffer
 */
unmanagedSources in Compile ++= ((fetchFlatbuffersLibTask.value / "java") ** "*.java").get

/**
 * directory for java code generated by flatbuffer
 * @see sourceManaged.value = ThisBuild / target / scala-2.11 / src_managed /
 */
val flatbuffersGenJavaDir = SettingKey[File]("flatbuffersGenJavaDir",
  "Location of Flatbuffers generated Java files.")
flatbuffersGenJavaDir := sourceManaged.value / "flatbuffers" / "gen-java"

/**
 * define a task to generate java sources from self-defined flatbuffer interface files
 * @return java files corresponding to fbs files
 */
val buildFlatbuffersTask = TaskKey[Seq[File]]("buildFlatbuffers",
  "Generates Java sources from Flatbuffers interface files, returning the Java sources.")
buildFlatbuffersTask := {
  import sys.process._
  val flatc = fetchFlatbuffersLibTask.value / "flatc"
  val flatbuffers = ((sourceDirectory.value / "flatbuffers") ** "*.fbs").get
  // Only regenerate Flatbuffers headers if any .fbs file changed, indicated by their latest
  // modification time being newer than all generated headers. We do this because regenerating
  // Flatbuffers headers causes a full enclave rebuild, which is slow.
  val fbsLastMod = flatbuffers.map(_.lastModified).max
  val gen = (flatbuffersGenJavaDir.value ** "*.java").get
  if (gen.isEmpty || fbsLastMod > gen.map(_.lastModified).max) {
    for (fbs <- flatbuffers) {
      streams.value.log.info(s"Generating flatbuffers for ${fbs}")
      if (Seq(flatc.getPath, "--java", "-o", flatbuffersGenJavaDir.value.getPath, fbs.getPath).! != 0) {
        sys.error("Flatbuffers build failed.")
      }
    }
  }
  (flatbuffersGenJavaDir.value ** "*.java").get
}

/**
 * re-assign sourceGenerators by append buildFlatbuffersTask
 */
sourceGenerators in Compile += buildFlatbuffersTask.taskValue

/**
 * define buildType for JNI build
 */
val buildType = SettingKey[BuildType]("buildType",
  "Release, Debug, or Profile.")
buildType := Release

/**
 * define a task to build natice C++ code by JNI
 * @return c shared library directory
 */
val nativeBuildTask = TaskKey[File]("nativeBuild", "Build native C++ code, returning the directory containing the resulting shared libraries.")
nativeBuildTask :={
  import sys.process._
  val nativeSourceDir = baseDirectory.value / "src" / "native"
  val nativeBuildDir = target.value / "native"
  nativeBuildDir.mkdirs()
  val cmakeResult =
    Process(Seq(
      "cmake",
      s"-DCMAKE_INSTALL_PREFIX:PATH=${nativeBuildDir.getPath}",
      s"-DCMAKE_BUILD_TYPE=${buildType.value}",
      nativeSourceDir.getPath), nativeBuildDir).!
  if (cmakeResult != 0) sys.error("native build failed.")
  val nproc = java.lang.Runtime.getRuntime.availableProcessors
  val buildResult = Process(Seq("make", "-j" + nproc), nativeBuildDir).!
  if (buildResult != 0) sys.error("C++ build failed.")
  val installResult = Process(Seq("make", "install"), nativeBuildDir).!
  if (installResult != 0) sys.error("C++ build failed.")
  nativeBuildDir / "lib"
}

/**
 * re-define baseDirectory used in nativeBuildTask
 */
baseDirectory in nativeBuildTask := (baseDirectory in ThisBuild).value

/**
 * re-define compile task by making nativeBuildTask as a prerequisite
 */
compile in Compile := { (compile in Compile).dependsOn(nativeBuildTask).value }

/**
 * define a task to copy native libraries to managed resources directory
 * @return all native library files
 */
val copyNativeLibrariesToResourcesTask = TaskKey[Seq[File]]("copyNativeLibrariesToResources",
  "Copies the native libraries to the managed resources directory, returning the copied files.")
copyNativeLibrariesToResourcesTask :={
  val libraries = (nativeBuildTask.value ** "*.so").get
  val mappings: Seq[(File, String)] =
    libraries pair rebase(nativeBuildTask.value , s"/native/${nativePlatform.value}")
  val resources: Seq[File] = for ((file, path) <- mappings) yield {
    val resource = resourceManaged.value / path
    IO.copyFile(file, resource)
    resource
  }
  val cryptoLib = ((baseDirectory.value / "tpl") ** "*.so").get
  val cryptoMappings: Seq[(File, String)] =
    cryptoLib pair rebase(baseDirectory.value / "tpl" , s"/native/${nativePlatform.value}")
  val cryptoResources: Seq[File] = for ((file, path) <- cryptoMappings) yield {
    val resource = resourceManaged.value / path
    IO.copyFile(file, resource)
    resource
  }
  resources ++ cryptoResources
}

/**
 * re-assign resourceGenerators by append copyNativeLibrariesToResourcesTask
 */
resourceGenerators in Compile += copyNativeLibrariesToResourcesTask.taskValue

/**
 * Add the managed resource directory to the resource classpath so we can find libraries at runtime
 */
managedResourceDirectories in Compile += resourceManaged.value

/**
 * define a task to collect platform-related information
 * @type {[type]}
 */
nativePlatform := {
  try {
    val lines = Process("uname -sm").lines
    if (lines.length == 0) {
      sys.error("Error occured trying to run `uname`")
    }
    // uname -sm returns "<kernel> <hardware name>"
    val parts = lines.head.split(" ")
    if (parts.length != 2) {
      sys.error("'uname -sm' returned unexpected string: " + lines.head)
    } else {
      val arch = parts(1).toLowerCase.replaceAll("\\s", "")
      val kernel = parts(0).toLowerCase.replaceAll("\\s", "")
      arch + "-" + kernel
    }
  } catch {
    case ex: Exception =>
      sLog.value.error("Error trying to determine platform.")
      sLog.value.warn("Cannot determine platform! It will be set to 'unknown'.")
      "unknown-unknown"
  }
}
