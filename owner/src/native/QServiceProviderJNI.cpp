#include "QSP.h"

#include "QServiceProvider.h"

#include <fstream>

/**
 * Throw a Java exception with the specified message.
 *
 * Important: Note that this function will return to the caller. The exception is only thrown at the
 * end of the JNI method invocation.
 */
extern void jni_throw(JNIEnv *env, const char *message);

JNIEXPORT void JNICALL Java_edu_xjtu_cs_cyx_qshield_owner_QSP_QInit
  (JNIEnv *env, jobject obj, jbyteArray shared_key, jstring param, jstring intel_cert){
  (void)env;
  (void)obj;

  jboolean if_copy = false;
  jbyte *shared_key_bytes = env->GetByteArrayElements(shared_key, &if_copy);

  const char *intel_cert_str = env->GetStringUTFChars(intel_cert, nullptr);
  size_t intel_cert_len = static_cast<size_t>(env->GetStringUTFLength(intel_cert));

  const char *param_str = env->GetStringUTFChars(param, nullptr);
  FILE *param_file = fopen(param_str, "r");
  if (param_file == nullptr){
    throw std::runtime_error(
      std::string("Error: Param file '")
      + param_str
      + std::string("' does not exist. "));
  }
  char param_data[10240];
  int count = fread(param_data, 1, 10240, param_file);
  if(!count){
    throw std::runtime_error(
      std::string("Error: Read Param file '")
      + param_str);
  }
  fclose(param_file);


  try {
    const char *private_key_path = std::getenv("PRIVATE_KEY_PATH");
    if (!private_key_path) {
      throw std::runtime_error(
        "Set $PRIVATE_KEY_PATH to the file generated by "
        "openssl ecparam -genkey, probably called ${OPAQUE_HOME}/private_key.pem.");  
    }
    qservice_provider.load_private_key(private_key_path);
    qservice_provider.set_shared_key(reinterpret_cast<uint8_t *>(shared_key_bytes));
    qservice_provider.setup(param_data, count);
    qservice_provider.connect_to_ias(std::string(intel_cert_str, intel_cert_len));
  } catch (const std::runtime_error &e) {
    jni_throw(env, e.what());
  }

  env->ReleaseByteArrayElements(shared_key, shared_key_bytes, 0);
  env->ReleaseStringUTFChars(intel_cert, intel_cert_str);
}

JNIEXPORT void JNICALL Java_edu_xjtu_cs_cyx_qshield_owner_QSP_QSPProcMsg0(
  JNIEnv *env, jobject obj, jbyteArray msg0_input) {
  (void)obj;

  jboolean if_copy = false;
  jbyte *msg0_bytes = env->GetByteArrayElements(msg0_input, &if_copy);
  uint32_t *extended_epid_group_id = reinterpret_cast<uint32_t *>(msg0_bytes);

  try {
    qservice_provider.process_msg0(*extended_epid_group_id);
  } catch (const std::runtime_error &e) {
    jni_throw(env, e.what());
  }

  env->ReleaseByteArrayElements(msg0_input, msg0_bytes, 0);
}

JNIEXPORT jbyteArray JNICALL Java_edu_xjtu_cs_cyx_qshield_owner_QSP_QSPProcMsg1(
  JNIEnv *env, jobject obj, jbyteArray msg1_input) {
  (void)obj;

  jboolean if_copy = false;
  jbyte *msg1_bytes = env->GetByteArrayElements(msg1_input, &if_copy);
  sgx_ra_msg1_t *msg1 = reinterpret_cast<sgx_ra_msg1_t *>(msg1_bytes);

  uint32_t msg2_size = 0;
  std::unique_ptr<sgx_ra_msg2_t> msg2;
  try {
    msg2 = qservice_provider.process_msg1(msg1, &msg2_size);
  } catch (const std::runtime_error &e) {
    jni_throw(env, e.what());
  }

  jbyteArray array_ret = env->NewByteArray(msg2_size);
  env->SetByteArrayRegion(array_ret, 0, msg2_size, reinterpret_cast<jbyte *>(msg2.get()));

  env->ReleaseByteArrayElements(msg1_input, msg1_bytes, 0);

  return array_ret;
}

JNIEXPORT jbyteArray JNICALL Java_edu_xjtu_cs_cyx_qshield_owner_QSP_QSPProcMsg3(
  JNIEnv *env, jobject obj, jbyteArray msg3_input) {
  (void)obj;

  jboolean if_copy = false;
  jbyte *msg3_bytes = env->GetByteArrayElements(msg3_input, &if_copy);
  sgx_ra_msg3_t *msg3 = reinterpret_cast<sgx_ra_msg3_t *>(msg3_bytes);
  uint32_t msg3_size = static_cast<uint32_t>(env->GetArrayLength(msg3_input));

  uint32_t msg4_size = 0;
  std::unique_ptr<q_ra_msg4_t> msg4;
  try {
    msg4 = qservice_provider.process_msg3(msg3, msg3_size, &msg4_size);
  } catch (const std::runtime_error &e) {
    jni_throw(env, e.what());
  }

  jbyteArray ret = env->NewByteArray(msg4_size);
  env->SetByteArrayRegion(ret, 0, msg4_size, reinterpret_cast<jbyte *>(msg4.get()));

  env->ReleaseByteArrayElements(msg3_input, msg3_bytes, 0);

  return ret;
}

JNIEXPORT jbyteArray JNICALL Java_edu_xjtu_cs_cyx_qshield_owner_QSP_QEncrypt
  (JNIEnv *env, jobject obj, jbyteArray pt){
  (void)obj;

  jboolean if_copy = false;
  jbyte *pt_bytes = env->GetByteArrayElements(pt, &if_copy);
  uint8_t *plaintext = reinterpret_cast<uint8_t *>(pt_bytes);
  int32_t plaintext_length = static_cast<uint32_t>(env->GetArrayLength(pt));

  int32_t ciphertext_length = qservice_provider.enc_size(plaintext_length);
  uint8_t *ciphertext_ptr = (uint8_t *)malloc(ciphertext_length);

  std::unique_ptr<uint8_t, decltype(&free)> ciphertext(ciphertext_ptr, &free);

  try{
    qservice_provider.encrypt(plaintext, plaintext_length, ciphertext.get());
  } catch (const std::runtime_error &e){
    jni_throw(env, e.what());
  }

  jbyteArray ret = env->NewByteArray(ciphertext_length);
  env->SetByteArrayRegion(ret, 0, ciphertext_length, reinterpret_cast<jbyte *>(ciphertext.get()));
  env->ReleaseByteArrayElements(pt, pt_bytes, 0);
  return ret;
}

JNIEXPORT jbyteArray JNICALL Java_edu_xjtu_cs_cyx_qshield_owner_QSP_QSkbDeliver
  (JNIEnv *env, jobject obj, jint u_id){
  (void)obj;

  element_t *sk_b = qservice_provider.get_skb(u_id);

  uint32_t sk_b_len = element_length_in_bytes(*sk_b);
  uint8_t sk_b_str[sk_b_len];
  element_to_bytes(sk_b_str, *sk_b);

  jbyteArray ret = env->NewByteArray(sk_b_len);
  env->SetByteArrayRegion(ret, 0, sk_b_len, reinterpret_cast<jbyte *>(sk_b_str));
  return ret;
}

JNIEXPORT jbyteArray JNICALL Java_edu_xjtu_cs_cyx_qshield_owner_QSP_QSk
  (JNIEnv *env, jobject obj){
  (void)obj;

  uint8_t *sk = (uint8_t *)malloc(16);
  qservice_provider.get_sk(&sk);

  jbyteArray ret = env->NewByteArray(16);
  env->SetByteArrayRegion(ret, 0, 16, reinterpret_cast<jbyte *>(sk));
  free(sk);
  return ret;


  }
